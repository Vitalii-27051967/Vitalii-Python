# 1) Создать список из 20 случайных целых чисел в диапазоне от 1 до 100.
# Задание можно выполнить и через обычный цикл и через генератор списков.
########################################################################

from random import randint, randrange       # Вопрос был спорным. Переделал по @miha-pavel

#  Вариант 1. Обычный цикл ###########
print("Задание 1. Вариант 1. Обычный цикл", end="\n\n")
my_list_1 = []
for num_1 in range(0, 20):
    my_list_1.append(randint(1, 100))
print(my_list_1, end="\n\n")


# Вариант 2. Генератор ############
print("Задание 1. Вариант 2. Генератор", end="\n\n")

my_list_2 = [randint(1, 100) for num_1 in range(0, 20)]
print(my_list_2, end="\n\n")


# 2) Создать словарь triangle в который записать точки A B C (ключи),
# и их координаты - кортежи (значения), созданные случайным образом с помощью модуля random
# в диапазоне от -10 до 10 по каждой оси.
########################################################################
print("Задание 2.", end="\n\n")

#  @miha-pavel Триугольник єто плоская фигура, ей не нужено три координаті.
# -----------------------------------------------------------------------------------------------------------------
# @Vitalii-27051967	Reply Тут могу не согласиться. По геометрии - на 3 точках в пространстве всегда можно разместить
# плоскость. triangle может находиться в пространстве с координатами вершин XYZ. Переделал, как Вам будет угодно :-)
# -----------------------------------------------------------------------------------------------------------------


def xy():
    x_y = tuple([randrange(-10, 10) for _ in range(2)])
    return x_y


triangle = {"A": xy(), "B": xy(), "C": xy()}
print("Координаты точек: ", triangle, end="\n\n")

# # 3) Создать функцию my_print, которая принимает в виде параметра строку и печатает ее
# # с тремя символами * вначале и в конце строки.
# # Пример:
# # my_str = 'I'm the string'
# # Печатает ***I'm the string***
########################################################################

print("Задание 3.", end="\n\n")
my_str = "I'm the string"


def my_print_f(str_d):
    print(f"***{str_d}***", end="\n\n")


my_print_f(my_str)


# 4) Дан список словарей persons в формате [{"name": "John", "age": 15}, ... ,{"name": "Jack", "age": 45}]
#       а) Напечатать имя самого молодого человека. Если возраст совпадает - напечатать все имена.
#       б) Напечатать самое длинное имя. Если длина имени совпадает - напечатать все имена.
#       в) Посчитать среднее количество лет всех людей из списка.
########################################################################

print("Задание 4.", end="\n\n")
persons = [{"name": "John", "age": 18},
           {"name": "Emmanuel", "age": 10},
           {"name": "Vitalii VM", "age": 9},
           {"name": "ZZtop", "age": 99},
           {"name": "Pink Floyd", "age": 100}]

num_people = len(persons)  # количество людей
ar_1 = []  # возраст
ar_2 = []  # имена
ar_3 = []  # длинные имена
sum_age = 0     # сумма лет
len_mame = 0    # значение длины имени
age_var = persons[0]["age"]  # считаем первого самым молодым

for dig in range(num_people):
    sum_age += persons[dig]["age"]        # накапливаем суму возрастов
    person_age = persons[dig]["age"]      # для удобства вводим переменную возраста
    person_name = persons[dig]["name"]    # для удобства вводим переменную имени

    if persons[dig]["age"] == age_var:    # если возраст как и у предыдущего, дописывем в список
        ar_1.append(person_age)
        ar_2.append(person_name)

    if persons[dig]["age"] < age_var:     # если возраст меньше чем предыдущего, то очищаем список и перезаписываем
        ar_1.clear()
        ar_2.clear()
        ar_1.append(person_age)
        ar_2.append(person_name)
        age_var = person_age              # переназначаем возраст

    if len(person_name) == len_mame:    # если длина как и у предыдущего, дописывем в список
        ar_3.append(person_name)

    if len(person_name) > len_mame:     # если длина больше чем предыдущего, то очищаем список и перезаписываем
        ar_3.clear()
        ar_3.append(person_name)
        len_mame = len(person_name)

print("Самый молодой ", ar_1, ar_2)
print("Средний возраст людей: ", sum_age / num_people)
print("Самые длинные имена: ", ar_3)
print(end='\n\n')

# 5) Даны два словаря my_dict_1 и my_dict_2.
#       а) Создать список из ключей, которые есть в обоих словарях.
#       б) Создать список из ключей, которые есть в первом, но нет во втором словаре.
#       в) Создать новый словарь из пар {ключ:значение}, для ключей, которые есть в первом, но нет во втором словаре.
#       г) Объединить эти два словаря в новый словарь по правилу:
#   если ключ есть только в одном из двух словарей - поместить пару ключ:значение,
#   если ключ есть в двух словарях - поместить пару {ключ: [значение_из_первого_словаря, значение_из_второго_словаря]}
########################################################################

print("Задание 5.", end="\n\n")
my_dict_1 = {"key 1": "key_1",
             "key 2": "key_2",
             "key 3": "key_3",
             "key 4": "key_4"}
my_dict_2 = {"key 1": "lock_1",
             "key 2": "lock_2",
             "key 33": "lock_33",
             "key 44": "lock_34"}

arl_1 = set(dict.keys(my_dict_1))       # ключи первого словаря
arl_2 = set(dict.keys(my_dict_2))       # ключи второго словаря
print(sorted(arl_1), sorted(arl_2), sep="\n", end="\n\n")

is_in = sorted(arl_1.intersection(arl_2))       # Список ключей, которые есть в обоих словарях
print("a) Ключи, которые есть в обоих словарях", is_in, end="\n\n")

non_in_1 = sorted(arl_1.difference(arl_2))      # Список ключей, которые есть только в первом словаре
print("б) Ключи, которые есть только в первом словаре", non_in_1, end="\n\n")

my_dict_3 = {value: my_dict_1[value] for value in non_in_1}  # словарь из знач., которые есть в 1, но нет во 2 словаре
print("в) Словарь из ключей, которые есть только в первом словаре: ", my_dict_3, end="\n\n")

arl = sorted(arl_1.union(arl_2))    # объединяем ключи и убираем дубли
my_list_n = []                      # список, куда будем сбрасывать промежуточные значения по ключу
my_dict_4 = {}                      # Новый словарь для объединения значений

for key_com in arl:
    if my_dict_1.get(key_com):      # @miha-pavel None писать не надо так, как get вернет его и так
        my_list_n.append(my_dict_1[key_com])
    if my_dict_2.get(key_com):
        my_list_n.append(my_dict_2[key_com])
    var = list(my_list_n)
    my_dict_4[key_com] = var        # записываем значения в словарь
    my_list_n.clear()               # очищаем от промежуточных значений для следующего цикла
print("г) Объединённое значений словарей:", my_dict_4, sep="\n\n")
